

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   dsCCPhos internal auxiliary functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' GetClass
#'
#' Wrapper around \code{base::class()} with more informative output
#'
#' @param Object Arbitrary R object
#' @return \code{string}
#' @keywords internal
#' @noRd
#-------------------------------------------------------------------------------
GetClass <- function(Object)
{
    require(tibble)

    Class <- class(Object)[1]      # Some objects return more than one string as class info (e.g. ResourceClient objects). Take only first string for these cases.

    if (is_tibble(Object)) { Class <- "tibble" }

    return(Class)
}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' .get_encode_dictionary
#'
#' Taken from dsTidyverse package. Generate an encoding key which is used for encoding and decoding strings to pass the R parser
#'
#' @return A list containing the encoding key, with 'input' specifying the characters to be encoded
#' and 'output' specifying their corresponding encoded values.
#' @keywords internal
#' @noRd
.get_encode_dictionary <- function()
{
  encode_list <- list(input = c("(", ")", "\"", ",", " ", "!", "&", "|", "'", "=", "+", "-", "*", "/", "^", ">", "<", "~", "\n"),
                      output = c("$LB$", "$RB$", "$QUOTE$", "$COMMA$", "$SPACE$", "$EXCL$", "$AND$", "$OR$",
                                 "$APO$", "$EQU$", "$ADD$", "$SUB$", "$MULT$", "$DIVIDE$", "$POWER$", "$GT$", "$LT$", "$TILDE$", "$LINE$"))

  return(encode_list)
}


#' Encode a string using the provided encoding key.
#'
#' @param input_string The string to be encoded.
#' @param encode_key The encoding key generated by '.get_encode_dictionary()'.
#' @return The encoded string.
#' @keywords internal
#' @noRd
.encode_tidy_eval <- function(input_string, encode_key)
{
  encode_vec <- encode_key$output
  names(encode_vec) <- encode_key$input
  split_string <- strsplit(input_string, "")[[1]]
  output_string <- sapply(split_string,
                          function(char)
                          {
                              if (char %in% names(encode_vec))
                              { encode_vec[[char]]
                              } else { char }
                          })
  return(paste(output_string, collapse = ""))
}


#' Decode a string using the provided encoding key.
#'
#' @param input_string The encoded string passed through the R parser.
#' @param encode_key The encoding key generated by '.get_encode_dictionary()'.
#' @return The decoded string.
#' @keywords internal
#' @noRd
.decode_tidy_eval <- function(input_string, encode_key)
{
  encode_vec <- encode_key$input
  names(encode_vec) <- encode_key$output

  output_string <- Reduce(function(out, pattern)
                          {
                              gsub(pattern, encode_vec[[pattern]], out, fixed = TRUE)
                          }, names(encode_vec), input_string)
  return(output_string)
}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
