# Posterior validity grade: To measure method performance calculate proportion of valid elements in 'BestMatches' after matching
ValidityGrade <- sum(BestMatches %in% EligibleStringsOriginal, na.rm = TRUE) / length(BestMatches)
MethodApplication[[CurrentMethod]] <- list(BestMatches = BestMatches,
ValidityGrade = ValidityGrade)
# If a method results in a perfect validity grade (so all elements in 'IneligibleStrings' can be matched with one in 'EligibleStringsOriginal'), the while-loop is stopped to save computational cost
if (ValidityGrade == 1) { FoundPerfectValidityGrade <- TRUE }
i <- i + 1
}
# Transpose list to ease further processing
MethodApplication <- MethodApplication %>% list_transpose()
# Determine best method based on highest posterior validity grade
BestMethod <- Methods[which.max(MethodApplication$ValidityGrade)]
# Get best matches of best method
BestMatches <- MethodApplication$BestMatches[[BestMethod]]
} else {
# Get best matches for every element in 'IneligibleStrings' with the method given in 'PreferredMethod' and return them
BestMatches <- sapply(IneligibleStrings,
GetBestMatch,
EligibleStringsOriginal = EligibleStringsOriginal,
EligibleStringsMod = EligibleStringsMod,
Method = PreferredMethod)
}
VectorTrackerW <- VectorTracker %>%
mutate(Match = BestMatches[Vector])
View(VectorTrackerW)
IneligibleStrings
cat(IneligibleStrings)
# Filter out strings that need matching
IneligibleStrings <- VectorTracker %>%
filter(!is.na(Vector),
!(Vector %in% EligibleStrings)) %>%
distinct(Vector)
IneligibleStrings
# Filter out strings that need matching
IneligibleStrings <- VectorTracker %>%
filter(!is.na(Vector),
!(Vector %in% EligibleStrings)) %>%
distinct(Vector) %>%
pull(Vector)
IneligibleStrings
# Initialize 'EligibleStringsMod' as a container for possible modifications of 'EligibleStrings'. The original 'EligibleStrings' are still needed later for the return value.
EligibleStringsOriginal <- EligibleStrings
EligibleStringsMod <- EligibleStrings
# For every preprocessing steps both input AND set of valid strings are being modified to enhance chance for matching
if (Preprocessing.FlattenCase == TRUE)
{
IneligibleStrings <- tolower(IneligibleStrings)
EligibleStringsMod <- tolower(EligibleStringsMod)
}
if (Preprocessing.SquishWhiteSpace == TRUE)
{
IneligibleStrings <- str_squish(IneligibleStrings)      # 'str_squish' removes all leading and trailing white space and reduces all internal white space to a single one
EligibleStringsMod <- str_squish(EligibleStringsMod)
}
if (Preprocessing.RemoveAllWhiteSpace == TRUE)
{
IneligibleStrings <- str_replace_all(IneligibleStrings, " ", "")      # Remove ALL white space
EligibleStringsMod <- str_replace_all(EligibleStringsMod, " ", "")
}
# Auxiliary function to get best fuzzy string match in 'EligibleStringsOriginal' for a particular string
GetBestMatch <- function(String,
EligibleStringsOriginal,
EligibleStringsMod,
Method)
{
# Return NA if String is NA
if (is.na(String)) { return(NA) }
# Compute string distances from current string to all valid strings
Distances <- stringdist(a = String,
b = EligibleStringsMod,
method = Method)
# The current string's lowest distance to any of the valid strings
lowestdistance <- min(Distances)
# Identify the valid string with smallest distance to current string
bestmatch <- EligibleStringsMod[which.min(Distances)]
# Depending on the used method 'lowestdistance' can either already be a number between 0 (no distance) and 1 (maximal distance) or it needs to be normalized accordingly to make the 'Tolerance' argument meaningful
lowestdistance.norm <- lowestdistance      # Methods 'jaccard', 'jw', 'cosine', 'soundex' return distance measures between 0 and 1
if (Method %in% c("osa", "lv", "dl"))      # Length-based edit distances
{
lowestdistance.norm <- lowestdistance / max(nchar(String), nchar(bestmatch))
}
if (Method %in% c("lcs", "qgram"))
{
lowestdistance.norm <- lowestdistance / (nchar(String) + nchar(bestmatch))
}
# Method 'hamming' returns Inf for two strings with different numbers of characters and is therefore not supported (because we can not find a maximum that would allow normalization)
# Get the original value of best match (before valid strings were modified)
bestmatch.original <- EligibleStringsOriginal[which(EligibleStringsMod == bestmatch)]
# If the normalized distance is lower or equal than the 'Tolerance' value, the best match is returned, otherwise return the current string as it was
if (lowestdistance.norm <= Tolerance) { return(bestmatch.original) }
else { return(NA) }
}
# Initialize vector for resulting best matches
BestMatches <- NULL
# If option 'FindBestMethod' is set to TRUE, try out available methods and choose the one with the highest posterior validity grade
if (FindBestMethod == TRUE)
{
# Suitable methods implemented in 'stringdist::stringdist()'
Methods <- c("osa", "lv", "dl", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex")
# Apply all methods and return results as well as method-specific performance (validity grade)
MethodApplication <- list()
FoundPerfectValidityGrade <- FALSE
i <- 1
while (FoundPerfectValidityGrade == FALSE & i <= length(Methods))
{
CurrentMethod <- Methods[i]
# Get best matches for every element in 'IneligibleStrings' with the current method
BestMatches <- sapply(IneligibleStrings,
GetBestMatch,
EligibleStringsOriginal = EligibleStringsOriginal,
EligibleStringsMod = EligibleStringsMod,
Method = CurrentMethod)
# Posterior validity grade: To measure method performance calculate proportion of valid elements in 'BestMatches' after matching
ValidityGrade <- sum(BestMatches %in% EligibleStringsOriginal, na.rm = TRUE) / length(BestMatches)
MethodApplication[[CurrentMethod]] <- list(BestMatches = BestMatches,
ValidityGrade = ValidityGrade)
# If a method results in a perfect validity grade (so all elements in 'IneligibleStrings' can be matched with one in 'EligibleStringsOriginal'), the while-loop is stopped to save computational cost
if (ValidityGrade == 1) { FoundPerfectValidityGrade <- TRUE }
i <- i + 1
}
# Transpose list to ease further processing
MethodApplication <- MethodApplication %>% list_transpose()
# Determine best method based on highest posterior validity grade
BestMethod <- Methods[which.max(MethodApplication$ValidityGrade)]
# Get best matches of best method
BestMatches <- MethodApplication$BestMatches[[BestMethod]]
} else {
# Get best matches for every element in 'IneligibleStrings' with the method given in 'PreferredMethod' and return them
BestMatches <- sapply(IneligibleStrings,
GetBestMatch,
EligibleStringsOriginal = EligibleStringsOriginal,
EligibleStringsMod = EligibleStringsMod,
Method = PreferredMethod)
}
VectorTrackerW <- VectorTracker %>%
mutate(Match = BestMatches[Vector])
View(VectorTrackerW)
BestMatches
Vector <- DataSet$Staging$UICCStage
EligibleStrings <- EligibleValueSets$UICCStage
PreferredMethod <- "jw"
FindBestMethod <- TRUE
Tolerance <- 0.5
Preprocessing.FlattenCase <- TRUE
Preprocessing.RemoveAllWhiteSpace <- FALSE
Preprocessing.SquishWhiteSpace <- TRUE
# 'Vector' and 'EligibleStrings' should be of type character already, explicitly convert here to make sure
Vector <- as.character(Vector)
EligibleStrings <- as.character(EligibleStrings)
# Initialize 'VectorTracker' to track processing and matching and to preserve original input vector
VectorTracker <- tibble(ID = 1:length(Vector),
Vector = Vector,
IsEligible = Vector %in% EligibleStrings,
Modification = Vector)
View(VectorTracker)
# Initialize 'VectorTracker' to track processing and matching and to preserve original input vector
VectorTracker <- tibble(ID = 1:length(Vector),
Vector = Vector,
IsIneligible = (is.na(Vector) | !(Vector %in% EligibleStrings)),
Modification = Vector)
View(VectorTracker)
# Initialize 'VectorTracker' to track processing and matching and to preserve original input vector
VectorTracker <- tibble(ID = 1:length(Vector),
Vector = Vector,
IsIneligible = !(Vector %in% EligibleStrings),
Modification = Vector)
View(VectorTracker)
# Initialize 'VectorTracker' to track processing and matching and to preserve original input vector
VectorTracker <- tibble(ID = 1:length(Vector),
Vector = Vector,
IsIneligible = !is.na(Vector) & !(Vector %in% EligibleStrings),
Modification = Vector)
# Initialize 'VectorTracker' to track processing and matching and to preserve original input vector
VectorTracker <- tibble(ID = 1:length(Vector),
Vector = Vector,
NeedsMatching = !is.na(Vector) & !(Vector %in% EligibleStrings),
Modification = Vector)
Vector <- DataSet$Staging$UICCStage
EligibleStrings <- EligibleValueSets$UICCStage
PreferredMethod <- "jw"
FindBestMethod <- TRUE
Tolerance <- 0.5
Preprocessing.FlattenCase <- TRUE
Preprocessing.RemoveAllWhiteSpace <- FALSE
Preprocessing.SquishWhiteSpace <- TRUE
# 'Vector' and 'EligibleStrings' should be of type character already, explicitly convert here to make sure
Vector <- as.character(Vector)
EligibleStrings <- as.character(EligibleStrings)
# Initialize 'VectorTracker' to track processing and matching and to preserve original input vector
VectorTracker <- tibble(ID = 1:length(Vector),
Vector = Vector,
NeedsMatching = !is.na(Vector) & !(Vector %in% EligibleStrings),
Modification = Vector)
# Initialize 'EligibleStringsTracker' to track processing of 'EligibleStrings' (they may be modified to facilitate matching)
EligibleStringsTracker <- tibble(Original = EligibleStrings,
Modification = EligibleStrings)
# For every preprocessing step elements in both 'Vector' AND 'EligibleStrings' are being modified to enhance chance for matching
if (Preprocessing.FlattenCase == TRUE)
{
VectorTracker <- VectorTracker %>% mutate(Modification = tolower(Modification))
EligibleStringsTracker <- EligibleStringsTracker %>% mutate(Modification = tolower(Modification))
}
if (Preprocessing.RemoveAllWhiteSpace == TRUE)
{
VectorTracker <- VectorTracker %>% mutate(Modification = str_replace_all(Modification, " ", ""))      # Remove ALL white space
EligibleStringsTracker <- EligibleStringsTracker %>% mutate(Modification = str_replace_all(Modification, " ", ""))
}
if (Preprocessing.SquishWhiteSpace == TRUE)
{
VectorTracker <- VectorTracker %>% mutate(Modification = str_squish(Modification))      # 'str_squish' removes all leading and trailing white space and reduces all internal white space to a single one
EligibleStringsTracker <- EligibleStringsTracker %>% mutate(Modification = str_squish(Modification))
}
View(EligibleStringsTracker)
View(VectorTracker)
# Filter out non-NA ineligible strings (ie strings that need matching)
IneligibleStrings <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
distinct(Modification) %>%
pull(Modification)
# Auxiliary function to get best fuzzy string match in 'EligibleStringsOriginal' for a particular string
GetBestMatch <- function(String,
EligibleStringsOriginal,
EligibleStringsModification,
Method)
{
# Return NA if String is NA
if (is.na(String)) { return(NA) }
# Compute string distances from current string to all valid strings
Distances <- stringdist(a = String,
b = EligibleStringsMod,
method = Method)
# The current string's lowest distance to any of the valid strings
lowestdistance <- min(Distances)
# Identify the valid string with smallest distance to current string
bestmatch <- EligibleStringsMod[which.min(Distances)]
# Depending on the used method 'lowestdistance' can either already be a number between 0 (no distance) and 1 (maximal distance) or it needs to be normalized accordingly to make the 'Tolerance' argument meaningful
lowestdistance.norm <- lowestdistance      # Methods 'jaccard', 'jw', 'cosine', 'soundex' return distance measures between 0 and 1
if (Method %in% c("osa", "lv", "dl"))      # Length-based edit distances
{
lowestdistance.norm <- lowestdistance / max(nchar(String), nchar(bestmatch))
}
if (Method %in% c("lcs", "qgram"))
{
lowestdistance.norm <- lowestdistance / (nchar(String) + nchar(bestmatch))
}
# Method 'hamming' returns Inf for two strings with different numbers of characters and is therefore not supported (because we can not find a maximum that would allow normalization)
# Get the original value of best match (before valid strings were modified)
bestmatch.original <- EligibleStringsOriginal[which(EligibleStringsMod == bestmatch)]
# If the normalized distance is lower or equal than the 'Tolerance' value, the best match is returned, otherwise return NA
if (lowestdistance.norm <= Tolerance) { return(bestmatch.original) }
else { return(NA) }
}
# Initialize vector for resulting best matches
BestMatches <- NULL
# Auxiliary function to get best fuzzy string match in 'EligibleStringsOriginal' for a particular string
GetBestMatch <- function(String,
EligibleStringsOriginal,
EligibleStringsModification,
Method)
{
# Return NA if String is NA
if (is.na(String)) { return(NA) }
# Compute string distances from current string to all valid strings
Distances <- stringdist(a = String,
b = EligibleStringsModification,
method = Method)
# The current string's lowest distance to any of the valid strings
lowestdistance <- min(Distances)
# Identify the valid string with smallest distance to current string
bestmatch <- EligibleStringsModification[which.min(Distances)]
# Depending on the used method 'lowestdistance' can either already be a number between 0 (no distance) and 1 (maximal distance) or it needs to be normalized accordingly to make the 'Tolerance' argument meaningful
lowestdistance.norm <- lowestdistance      # Methods 'jaccard', 'jw', 'cosine', 'soundex' return distance measures between 0 and 1
if (Method %in% c("osa", "lv", "dl"))      # Length-based edit distances
{
lowestdistance.norm <- lowestdistance / max(nchar(String), nchar(bestmatch))
}
if (Method %in% c("lcs", "qgram"))
{
lowestdistance.norm <- lowestdistance / (nchar(String) + nchar(bestmatch))
}
# Method 'hamming' returns Inf for two strings with different numbers of characters and is therefore not supported (because we can not find a maximum that would allow normalization)
# Get the original value of best match (before valid strings were modified)
bestmatch.original <- EligibleStringsOriginal[which(EligibleStringsModification == bestmatch)]
# If the normalized distance is lower or equal than the 'Tolerance' value, the best match is returned, otherwise return NA
if (lowestdistance.norm <= Tolerance) { return(bestmatch.original) }
else { return(NA) }
}
# Initialize vector for resulting best matches
BestMatches <- NULL
# Suitable methods implemented in 'stringdist::stringdist()'
Methods <- c("osa", "lv", "dl", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex")
# Apply all methods and return results as well as method-specific performance (validity grade)
MethodApplication <- list()
FoundPerfectValidityGrade <- FALSE
i <- 1
while (FoundPerfectValidityGrade == FALSE & i <= length(Methods))
{
CurrentMethod <- Methods[i]
# Get best matches for every element in 'IneligibleStrings' with the current method
BestMatches <- sapply(IneligibleStrings,
GetBestMatch,
EligibleStringsOriginal = EligibleStringsTracker$Original,
EligibleStringsModification = EligibleStringsTracker$Modification,
Method = CurrentMethod)
# Posterior validity grade: To measure method performance calculate proportion of valid elements in 'BestMatches' after matching
ValidityGrade <- sum(BestMatches %in% EligibleStringsOriginal, na.rm = TRUE) / length(BestMatches)
MethodApplication[[CurrentMethod]] <- list(BestMatches = BestMatches,
ValidityGrade = ValidityGrade)
# If a method results in a perfect validity grade (so all elements in 'IneligibleStrings' can be matched with one in 'EligibleStringsOriginal'), the while-loop is stopped to save computational cost
if (ValidityGrade == 1) { FoundPerfectValidityGrade <- TRUE }
i <- i + 1
}
# Transpose list to ease further processing
MethodApplication <- MethodApplication %>% list_transpose()
MethodApplication$ValidityGrade
# Determine best method based on highest posterior validity grade
BestMethod <- Methods[which.max(MethodApplication$ValidityGrade)]
# Get best matches of best method
BestMatches <- MethodApplication$BestMatches[[BestMethod]]
BestMatches
VectorTrackerW <- VectorTracker %>%
mutate(Match = BestMatches[Modification])
View(VectorTrackerW)
?setNames
setNames("ABC", "g")
setNames("ABC", "123")
setNames("ABC", "12/&%$(§h")
setNames("ABC", "12/&%$|//\\6h")
# use_r("CompileTransFeatureRules")
# use_r("CompileTransformativeAssignments")
# use_r("CountDeviations")
# use_r("CreateEventFeatures")
# use_r("DataListToDataModel")
# use_r("DataModelToCSV")
# use_r("DataModelToDB")
# use_r("FinalizeDataTransformation")
# use_r("FindRedundantEntries")
# use_r("FormatData")
use_r("GetBestMatch")
devtools::load_all(".")
?map_vec
# Get best matches for every element in 'IneligibleStrings' with the method given in 'PreferredMethod' and return them
BestMatches <- IneligibleStrings %>%
map_vec(function(string) dsCCPhos::GetBestStringMatch(String = string,
EligibleStrings = EligibleStringsTracker$Modification,
Method = PreferredMethod,
Tolerance = Tolerance))
BestMatches
# Get best matches for every element in 'IneligibleStrings' with the method given in 'PreferredMethod' and return them
BestMatches <- IneligibleStrings %>%
map_vec(function(string) dsCCPhos::GetBestStringMatch(String = string,
EligibleStrings = EligibleStringsTracker$Modification,
Method = PreferredMethod,
Tolerance = Tolerance)) %>%
setNames(IneligibleStrings)
BestMatches
# Get best matches for every element in 'IneligibleStrings' with the method given in 'PreferredMethod' and return them
BestMatches <- IneligibleStrings %>%
map_vec(\(string) dsCCPhos::GetBestStringMatch(String = string,
EligibleStrings = EligibleStringsTracker$Modification,
Method = PreferredMethod,
Tolerance = Tolerance)) %>%
setNames(IneligibleStrings)
BestMatches
Vector <- DataSet$Staging$UICCStage
EligibleStrings <- EligibleValueSets$UICCStage
PreferredMethod <- "jw"
FindBestMethod <- TRUE
Tolerance <- 0.5
Preprocessing.FlattenCase <- TRUE
Preprocessing.RemoveAllWhiteSpace <- FALSE
Preprocessing.SquishWhiteSpace <- TRUE
# 'Vector' and 'EligibleStrings' should be of type character already, explicitly convert here to make sure
Vector <- as.character(Vector)
EligibleStrings <- as.character(EligibleStrings)
# Initialize 'VectorTracker' to track processing and matching and to preserve original input vector
VectorTracker <- tibble(ID = 1:length(Vector),
Vector = Vector,
NeedsMatching = !is.na(Vector) & !(Vector %in% EligibleStrings),
Modification = Vector)
# Initialize 'EligibleStringsTracker' to track processing of 'EligibleStrings' (they may be modified to facilitate matching)
EligibleStringsTracker <- tibble(Original = EligibleStrings,
Modification = EligibleStrings)
# For every preprocessing step elements in both 'Vector' AND 'EligibleStrings' are being modified to enhance chance for matching
if (Preprocessing.FlattenCase == TRUE)
{
VectorTracker <- VectorTracker %>% mutate(Modification = tolower(Modification))
EligibleStringsTracker <- EligibleStringsTracker %>% mutate(Modification = tolower(Modification))
}
if (Preprocessing.RemoveAllWhiteSpace == TRUE)
{
VectorTracker <- VectorTracker %>% mutate(Modification = str_replace_all(Modification, " ", ""))      # Remove ALL white space
EligibleStringsTracker <- EligibleStringsTracker %>% mutate(Modification = str_replace_all(Modification, " ", ""))
}
if (Preprocessing.SquishWhiteSpace == TRUE)
{
VectorTracker <- VectorTracker %>% mutate(Modification = str_squish(Modification))      # 'str_squish' removes all leading and trailing white space and reduces all internal white space to a single one
EligibleStringsTracker <- EligibleStringsTracker %>% mutate(Modification = str_squish(Modification))
}
# Filter out non-NA ineligible strings (ie strings that need matching)
IneligibleStrings <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
distinct(Modification) %>%
pull(Modification)
# Initialize vector for resulting best matches
BestMatches <- NULL
# If option 'FindBestMethod' is set to TRUE, try out available methods and choose the one with the highest posterior validity grade
if (FindBestMethod == TRUE)
{
# Suitable methods implemented in 'stringdist::stringdist()'
Methods <- c("osa", "lv", "dl", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex")
# Apply all methods and return results as well as method-specific performance (validity grade)
MethodApplication <- list()
FoundPerfectValidityGrade <- FALSE
i <- 1
while (FoundPerfectValidityGrade == FALSE & i <= length(Methods))
{
CurrentMethod <- Methods[i]
# Get best matches for every element in 'IneligibleStrings' with the current method
BestMatches <- IneligibleStrings %>%
map_vec(\(string) dsCCPhos::GetBestStringMatch(String = string,
EligibleStrings = EligibleStringsTracker$Modification,
Method = CurrentMethod,
Tolerance = Tolerance)) %>%
setNames(IneligibleStrings)
# Posterior validity grade: To measure method performance calculate proportion of valid elements in 'BestMatches' after matching
ValidityGrade <- sum(BestMatches %in% EligibleStringsTracker$Modification, na.rm = TRUE) / length(BestMatches)
MethodApplication[[CurrentMethod]] <- list(BestMatches = BestMatches,
ValidityGrade = ValidityGrade)
# If a method results in a perfect validity grade (so all elements in 'IneligibleStrings' can be matched with one in 'EligibleStringsOriginal'), the while-loop is stopped to save computational cost
if (ValidityGrade == 1) { FoundPerfectValidityGrade <- TRUE }
i <- i + 1
}
# Transpose list to ease further processing
MethodApplication <- MethodApplication %>% list_transpose()
# Determine best method based on highest posterior validity grade
BestMethod <- Methods[which.max(MethodApplication$ValidityGrade)]
# Get best matches of best method
BestMatches <- MethodApplication$BestMatches[[BestMethod]]
} else {
# Get best matches for every element in 'IneligibleStrings' with the method given in 'PreferredMethod'
BestMatches <- IneligibleStrings %>%
map_vec(\(string) dsCCPhos::GetBestStringMatch(String = string,
EligibleStrings = EligibleStringsTracker$Modification,
Method = PreferredMethod,
Tolerance = Tolerance)) %>%
setNames(IneligibleStrings)
}
VectorTrackerW <- VectorTracker %>%
mutate(Match = BestMatches[Modification])
View(VectorTrackerW)
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
mutate(Match = BestMatches[Modification])
BestMatches
BestMatchesW <- EligibleStringsTracker$Original[EligibleStringsTracker$Modification]
BestMatchesW
?join_by
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
mutate(ModificationMatch = BestMatches[Modification]) %>%
left_join(EligibleStringsTracker, by = join_by(ModificationMatch == Modification))
View(VectorTrackerW)
?rename
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
mutate(ModificationMatch = BestMatches[Modification]) %>%
left_join(EligibleStringsTracker, by = join_by(ModificationMatch == Modification)) %>%
rename(Match = "Original")
?is_na
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
mutate(ModificationMatch = BestMatches[Modification]) %>%
left_join(EligibleStringsTracker, by = join_by(ModificationMatch == Modification)) %>%
rename(Match = "Original") %>%
mutate(Output = case_when(!is.na(Match) ~ Match,
.default = Vector))
View(VectorTrackerW)
VectorTrackerW <- VectorTracker %>%
split(.$NeedsMatching)
VectorTrackerW$`FALSE`
?split
VectorTracker.Matches <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
mutate(ModificationMatch = BestMatches[Modification]) %>%
left_join(EligibleStringsTracker, by = join_by(ModificationMatch == Modification)) %>%
rename(Match = "Original") %>%
mutate(Output = case_when(!is.na(Match) ~ Match,
.default = Vector))
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == FALSE) %>%
left_join(VectorTracker.Matches, by = join_by(ID))
View(VectorTrackerW)
View(VectorTracker)
VectorTrackerW <- VectorTracker %>%
left_join(VectorTracker.Matches, by = join_by(ID))
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == FALSE) %>%
mutate(Output = Vector) %>%
bind_rows(VectorTracker.Matches)
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == FALSE) %>%
mutate(Output = Vector) %>%
bind_rows(VectorTracker.Matches) %>%
arrange(ID)
?arrange
VectorTracker <- VectorTracker %>%
filter(NeedsMatching == FALSE) %>%
mutate(Output = Vector) %>%
bind_rows(VectorTracker.Matches) %>%
arrange(ID)
devtools::load_all(".")
