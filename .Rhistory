.f = function(TransformationTrack, FinalizedDataFrame, MonitorMetaData)
{
if (purrr::is_empty(MonitorMetaData) == FALSE)
{
FinalizedValues <- FinalizedDataFrame %>%
select(c("TrackID", names(MonitorMetaData))) %>%
rename_with(.fn = ~ str_c(., "__Final"),   # Two underscores for later use in pivot_longer()
.cols = all_of(names(MonitorMetaData)))
TransformationTrack %>%
left_join(FinalizedValues,
by = join_by(TrackID)) %>%
distinct(pick(contains("__Raw")), .keep_all = TRUE)
}
else { return(data.frame()) }
})
} else {
stop("Internal error: Object names in ls_TransformationTracks, DataSet and ls_MonitorMetaData must be identical and in the same order.")
}
# Get counts of all distinct values in finalized data sets
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Check if object names in DataSet and ls_MonitorMetaData are identical to avoid incorrect mapping
if (all(names(DataSet) == names(ls_MonitorMetaData)))
{
ls_ValueCounts_Final <- map2(.x = DataSet,
.y = ls_MonitorMetaData,
.f = function(DataFrame, MonitorMetaData)
{
DataFrame %>%
dsCCPhos::TrackValueCounts(FeatureNames = names(MonitorMetaData),
TransformationStage = "Final") %>%
select(Feature,
Value,
Frequency) %>%
rename(Value_Final = Value,
Count_Final = Frequency)
})
} else {
stop("Internal error: Object names in DataSet and ls_MonitorMetaData must be identical and in the same order.")
}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Module C 9)  Merge monitor objects into coherent summaries
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Summarize Transformation Tracks
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_TransformationTracks_Summaries <- pmap(.l = list(ls_TransformationTracks,
ls_MonitorMetaData),
.f = function(TrackData,
MonitorMetaData)
{
if (!purrr::is_empty(TrackData)) { if (nrow(TrackData) > 0)
{
Summary <- TrackData %>%
mutate(across(everything(), ~ as.character(.x))) %>%      # Turn all columns into character (necessary for pivot_longer() to work correctly)
tidyr::pivot_longer(cols = c(everything(), -TrackID),
names_to = c("Feature", "Stage"),
names_sep = "(__)",      # Separate by '__'-string (two underscores)
values_to = "Value") %>%
tidyr::pivot_wider(names_from = Stage,
values_from = Value) %>%
select(-TrackID) %>%
distinct() %>%
rename(Value_Raw = Raw,
Value_Harmonized = Harmonized,
Value_Recoded = Recoded,
Value_Final = Final) %>%
rowwise() %>%
mutate(IsOccurring = TRUE,
IsEligible_Raw = ifelse(is.na(Value_Raw) | is.null(MonitorMetaData[[Feature]]),      # If value is NA or if there is no set of eligible values, set variable NA...
NA,
Value_Raw %in% MonitorMetaData[[Feature]]$Value_Raw),      # ... else check if specific row value is in set of eligible values
IsEligible_Harmonized = ifelse(is.na(Value_Harmonized) | is.null(MonitorMetaData[[Feature]]),
NA,
Value_Harmonized %in% MonitorMetaData[[Feature]]$Value_Raw),
IsEligible_Recoded = ifelse(is.na(Value_Recoded) | is.null(MonitorMetaData[[Feature]]),
NA,
Value_Recoded %in% MonitorMetaData[[Feature]]$Value_Curated),
IsEligible_Final = ifelse(is.na(Value_Final),
NA,
TRUE)) %>%
ungroup()
# Add set of all eligible values regardless of occurrence to summary
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
for (i in 1:length(MonitorMetaData))   # Loop through all monitored features of a table
{
AllEligibleValues <- tibble(Feature = names(MonitorMetaData)[i],
Value_Raw = MonitorMetaData[[i]]$Value_Raw,
IsOccurring = FALSE,
IsEligible_Raw = TRUE)
Summary <- bind_rows(Summary,
AllEligibleValues)
}
# Filter out eligible values marked as not occurring if they actually occur
# Result: All eligible values are included in summary, regardless of occurrence
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Summary <- Summary %>%
group_by(Feature, Value_Raw) %>%
arrange(desc(IsOccurring), .by_group = TRUE) %>%
slice_head() %>%
ungroup() %>%
arrange(Feature,
desc(IsOccurring),
desc(IsEligible_Raw),
desc(IsEligible_Harmonized),
Value_Raw)
return(Summary)
}
else { return (data.frame()) } }
else { return (data.frame()) }
})
# Create detailed transformation monitors
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   - Joining of info from transformation tracks and value counts
#-------------------------------------------------------------------------------
ls_TransformationMonitors <- pmap(.l = list(ls_TransformationTracks_Summaries,
ls_ValueCounts_Raw,
ls_ValueCounts_Harmonized,
ls_ValueCounts_Recoded,
ls_ValueCounts_Final),
.f = function(TransformationTracksSummary,
ValueCountsRaw,
ValueCountsHarmonized,
ValueCountsRecoded,
ValueCountsFinal)
{
if (nrow(TransformationTracksSummary) > 0)
{
TransformationTracksSummary %>%
left_join(ValueCountsRaw, by = c("Feature", "Value_Raw")) %>%
left_join(ValueCountsHarmonized, by = c("Feature", "Value_Harmonized")) %>%
left_join(ValueCountsRecoded, by = c("Feature", "Value_Recoded")) %>%
left_join(ValueCountsFinal, by = c("Feature", "Value_Final")) %>%
mutate(Count_Harmonized = case_when(IsOccurring == FALSE ~ NA_integer_,
TRUE ~ Count_Harmonized),
Count_Recoded = case_when(IsOccurring == FALSE ~ NA_integer_,
TRUE ~ Count_Recoded),
Count_Final = case_when(IsOccurring == FALSE ~ NA_integer_,
TRUE ~ Count_Final)) %>%
arrange(Feature,
desc(IsOccurring),
desc(IsEligible_Raw),
desc(IsEligible_Harmonized),
Value_Raw)
}
else { return(NULL) }
})
# Create overview of value eligibility in different transformation stages
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_EligibilityOverviews <- pmap(.l = list(ls_TransformationMonitors,
ls_MonitorMetaData),
.f = function(MonitorData,
MonitorMetaData)
{
if (!(purrr::is_empty(MonitorData) | is.null(MonitorData)))
{
# Filter out features that are not meant to be monitored, e.g. do not have applicable eligibility criteria
MonitorData <- MonitorData %>%
filter(Feature %in% names(MonitorMetaData))
SummaryRaw <- MonitorData %>%
group_by(Feature, IsEligible_Raw) %>%
summarize(Raw = sum(Count_Raw, na.rm = TRUE)) %>%
rename(Eligibility = IsEligible_Raw)
SummaryHarmonized <- MonitorData %>%
distinct(pick(Feature, Value_Harmonized), .keep_all = TRUE) %>%
group_by(Feature, IsEligible_Harmonized) %>%
summarize(Harmonized = sum(Count_Harmonized, na.rm = TRUE)) %>%
rename(Eligibility = IsEligible_Harmonized)
SummaryRecoded <- MonitorData %>%
distinct(pick(Feature, Value_Recoded), .keep_all = TRUE) %>%
group_by(Feature, IsEligible_Recoded) %>%
summarize(Recoded = sum(Count_Recoded, na.rm = TRUE)) %>%
rename(Eligibility = IsEligible_Recoded)
SummaryFinal <- MonitorData %>%
distinct(pick(Feature, Value_Final), .keep_all = TRUE) %>%
group_by(Feature, IsEligible_Final) %>%
summarize(Final = sum(Count_Final, na.rm = TRUE)) %>%
rename(Eligibility = IsEligible_Final)
Overview <- SummaryRaw %>%
full_join(SummaryHarmonized, by = join_by(Feature, Eligibility)) %>%
full_join(SummaryRecoded, by = join_by(Feature, Eligibility)) %>%
full_join(SummaryFinal, by = join_by(Feature, Eligibility)) %>%
arrange(Feature, desc(Eligibility)) %>%
mutate(Eligibility = case_match(Eligibility,
TRUE ~ "Eligible",
FALSE ~ "Ineligible",
NA ~ "Missing"))
# Get tibble of all combinations of occurring features and eligibility category
AllCombinations <- tibble(Feature = rep(unique(Overview$Feature), each = 3),
Eligibility = rep(c("Eligible", "Ineligible", "Missing"), times = length(unique(Overview$Feature))))
# Finalize overview
Overview <- Overview %>%
right_join(AllCombinations, by = join_by(Feature, Eligibility)) %>%
mutate(across(c(Raw, Harmonized, Recoded, Final), ~ case_when(is.na(.x) ~ 0, .default = .x))) %>%       # Turn all NAs into 0 in count columns
group_by(Feature) %>%
mutate(across(c(Raw, Harmonized, Recoded, Final), ~ .x / sum(.x), .names = "{.col}_Proportional")) %>%      # Create proportional value columns
ungroup() %>%
arrange(Feature, factor(Eligibility, levels = c("Eligible", "Ineligible", "Missing")))
}
else { return(data.frame()) }
})
# Create overview of value eligibility in different transformation stages
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_ValueSetOverviews <- ls_TransformationMonitors %>%
map(function(MonitorData)
{
if (!purrr::is_empty(MonitorData))
{
ValueSets <- list()
ValueSets$Raw <- MonitorData %>%
select(Feature, Value_Raw, IsOccurring, IsEligible_Raw, Count_Raw) %>%
group_by(Feature) %>%
mutate(Proportion_Raw = Count_Raw / sum(Count_Raw, na.rm = TRUE)) %>%
ungroup()
ValueSets$Harmonized <- MonitorData %>%
group_by(Feature, Value_Harmonized, IsEligible_Harmonized) %>%
summarize(Count_Harmonized = sum(Count_Harmonized, na.rm = TRUE)) %>%
ungroup() %>%
distinct(Feature, Value_Harmonized, .keep_all = TRUE) %>%
group_by(Feature) %>%
mutate(Proportion_Harmonized = Count_Harmonized / sum(Count_Harmonized, na.rm = TRUE)) %>%
ungroup()
ValueSets$Recoded <- MonitorData %>%
group_by(Feature, Value_Recoded, IsEligible_Recoded) %>%
summarize(Count_Recoded = sum(Count_Recoded, na.rm = TRUE)) %>%
ungroup() %>%
distinct(Feature, Value_Recoded, .keep_all = TRUE) %>%
group_by(Feature) %>%
mutate(Proportion_Recoded = Count_Recoded / sum(Count_Recoded, na.rm = TRUE)) %>%
ungroup()
ValueSets$Final <- MonitorData %>%
group_by(Feature, Value_Final, IsEligible_Final) %>%
summarize(Count_Final = sum(Count_Final, na.rm = TRUE)) %>%
ungroup() %>%
distinct(Feature, Value_Final, .keep_all = TRUE) %>%
group_by(Feature) %>%
mutate(Proportion_Final = Count_Final / sum(Count_Final, na.rm = TRUE)) %>%
ungroup()
return(ValueSets)
} else { return(list()) }
})
# Delete artificial "TrackID"-column from data frames (not needed anymore)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DataSet <- DataSet %>%
map(function(Table)
{
try(Table %>% select(-TrackID))
})
# Print info message
cli::cat_bullet("Data transformation monitors are stored in 'CurationReport$Transformation'", bullet = "info")
cat("\n")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# MODULE D)  Secondary entry exclusion
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   - Remove ineligible entries that may have been introduced during processing
#   - Same proceedings as in primary table cleaning (Module B))
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
ProgressBar <- progress_bar$new(format = "Secondary exclusion: Excluding ineligible table entries... [:bar] :percent in :elapsed  :spin",
total = length(DataSet), clear = FALSE, width = 100)
#-------------------------------------------------------------------------------
DataSetRoot <- DataSet$Patient %>%
left_join(DataSet$Diagnosis, by = join_by(PatientID)) %>%
CleanTable(TableNameLookup = c("Diagnosis", "Patient"),
RemoveRedundantEntries = FALSE,
FeatureObligations_RuleSet = Settings$FeatureObligations_RuleSet,
FeatureObligations_Profile = Settings$FeatureObligations_Profile) %>%
select(PatientID, DiagnosisID) %>%
distinct()
DataSet <- DataSet %>%
imap(function(Table, tablename)
{
try(ProgressBar$tick())
if (!(is.null(Table) | length(Table) == 0 | nrow(Table) == 0))
{
# Join current table with preselection of 'DataSetRoot'
if (tablename %in% c("BioSampling", "GeneralCondition", "Patient", "TherapyRecommendation"))
{
Table <- DataSetRoot %>%
select(PatientID) %>%
distinct() %>%
left_join(Table, by = join_by(PatientID))
} else {
Table <- DataSetRoot %>%
left_join(Table, by = join_by(PatientID, DiagnosisID))
}
# Clean current table using auxiliary function dsCCPhos::CleanTable()
CleanedTable <- Table %>%
CleanTable(TableNameLookup = tablename,
RemoveRedundantEntries = TRUE,
FeatureObligations_RuleSet = Settings$FeatureObligations_RuleSet,
FeatureObligations_Profile = Settings$FeatureObligations_Profile)
return(CleanedTable)
} else {
return(Table)
}
})
try(ProgressBar$terminate())
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# MONITORING: Count ineligible entries after secondary exclusion
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Count entries in data frames after secondary exclusion
CountEntries_AfterSecondaryExclusion <- DataSet %>%
map_int(\(Table) ifelse (!is.null(nrow(Table)), nrow(Table), 0))
# Count excluded entries
CountExcludedEntries_Secondary <- CountEntries_AfterPrimaryExclusion - CountEntries_AfterSecondaryExclusion
# Print messages for live monitoring in local tests
for (i in 1:length(CountExcludedEntries_Secondary))
{
Message <- paste0("Secondary exclusion: Removed ", CountExcludedEntries_Secondary[i], " ineligible entries from '", names(CountExcludedEntries_Secondary)[i], "' table.")
cli::cat_bullet(Message, bullet = "info")
# Save messages in output object
Messages$ExcludedEntries_Secondary <- c(Messages$ExcludedEntries_Secondary,
info = Message)
}
cat("\n")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# MODULE E)  Find and remove secondary redundancies (table entries that can be considered redundant when they provide no additional informational value compared to a previous entry)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1)  Process table 'Diagnosis' first, since other tables hold primary key 'DiagnosisID'.
#     Any DiagnosisIDs that are removed due to redundancy need to be replaced in dependent tables.
# 2)  Proceed with all other tables (excluding 'Patient')
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
ProgressBar <- progress_bar$new(format = "Removing redundant table entries... [:bar] :percent in :elapsed  :spin",
total = length(DataSet) - 1, clear = FALSE, width= 100)
#-------------------------------------------------------------------------------
try(ProgressBar$tick())
# Using dsCCPhos::FindRedundantEntries(), mark redundant entries in table 'Diagnosis' for further processing
Aux_DiagnosisRedundancies <- DataSet$Diagnosis %>%
FindRedundantEntries(PrimaryKeyFeature = "DiagnosisID",
DiscriminatoryFeatures = Meta_Features %>%
filter(TableName_Curated == "Diagnosis", IsDiscriminatory == TRUE) %>%
pull(FeatureName_Curated),
EssentialFeatures = Meta_Features %>%
filter(TableName_Curated == "Diagnosis", IsEssential == TRUE) %>%
pull(FeatureName_Curated),
RemoveRedundantEntries = FALSE)
# Any DiagnosisIDs that are removed due to redundancy need to be replaced in dependent tables
# Create a mapping structure to know which IDs to replace
Aux_RedundanciesIDMapping <- Aux_DiagnosisRedundancies %>%
filter(IsRedundant == TRUE) %>%
select(PatientID, DiagnosisID, ReferenceID)
# For messaging and reporting count
# a) Number of redundant diagnosis entries and
# b) Number of patients that had redundant diagnosis entries
#-------------------------------------------------------------------------------
CountRedundancies_Diagnosis <- Aux_DiagnosisRedundancies %>%
filter(IsRedundant == TRUE) %>%
nrow()
CountPatientsWithRedundancies_Diagnosis <- Aux_DiagnosisRedundancies %>%
filter(IsRedundant == TRUE) %>%
pull(PatientID) %>%
n_distinct()
# Print message for live monitoring in local tests
Message <- paste0("Found ", CountRedundancies_Diagnosis, " redundancies related to ", CountPatientsWithRedundancies_Diagnosis, " patient IDs.")
cli::cat_bullet(Message, bullet = "info")
cat("\n")
# Save message in output object
Messages$DiagnosisRedundancies <- Message
#-------------------------------------------------------------------------------
# Afterwards, remove redundant entries from 'Diagnosis'
DataSet$Diagnosis <- Aux_DiagnosisRedundancies %>%
filter(IsRedundant == FALSE) %>%
select(-IsRedundant,
-ReferenceID)
Table <- DataSet$BioSampling
tablename <- "BioSampling"
Table <- Table %>%
left_join(Aux_RedundanciesIDMapping, by = join_by(PatientID,
DiagnosisID)) %>%
mutate(DiagnosisID = ifelse(!is.na(ReferenceID),
ReferenceID,
DiagnosisID)) %>%
select(-ReferenceID)
# ... then proceed with secondary redundancy removal
Table <- Table %>%
FindRedundantEntries(PrimaryKeyFeature = Meta_Features %>%
filter(TableName_Curated == tablename, IsPrimaryKey = TRUE) %>%
pull(FeatureName_Curated),
DiscriminatoryFeatures = Meta_Features %>%
filter(TableName_Curated == tablename, IsDiscriminatory == TRUE) %>%
pull(FeatureName_Curated),
EssentialFeatures = Meta_Features %>%
filter(TableName_Curated == tablename, IsEssential == TRUE) %>%
pull(FeatureName_Curated),
RemoveRedundantEntries = TRUE)
rlang::last_trace()
Table <- DataSet$BioSampling
PrimaryKeyFeature <- "SampleID"
DiscriminatoryFeatures <- Meta_Features %>% filter(TableName_Curated == "BioSampling", IsDiscriminatory == TRUE) %>% pull(FeatureName_Curated)
EssentialFeatures <- Meta_Features %>% filter(TableName_Curated == "BioSampling", IsEssential == TRUE) %>% pull(FeatureName_Curated)
RemoveRedundantEntries <- TRUE
# Create auxiliary ID feature to keep track of table entries throughout function
if (!("AuxID" %in% names(Table)))
{
Table <- Table %>% ungroup() %>% mutate(AuxID = row_number())
} else {    # In the (unlikely) case of preexistence of a feature named 'AuxID' stop and print error message
stop("ERROR: The passed table contains a feature called 'AuxID' which interferes with function protocol. Please rename this feature and try again.", call. = FALSE)
}
# Reorder feature names in 'DiscriminatoryFeatures' according to correct stratification, defined by column order in 'Table'
DiscriminatoryFeatures <- names(Table)[names(Table) %in% DiscriminatoryFeatures]
# Reduce table to subset of entries that are potentially redundant to decrease computational workload
PotentialRedundancies <- Table %>%
group_by(across(all_of(DiscriminatoryFeatures))) %>%      # Group by features defined 'DiscriminatoryFeatures' to perform sensible initial stratification
summarize(EntryCount = n()) %>%
filter(EntryCount > 1) %>%      # Filter out entries that have no potential redundancies
select(-EntryCount) %>%
ungroup() %>%
left_join(Table) %>%      # Per default the join operation is performed on all common features
suppressMessages()
View(PotentialRedundancies)
# Initially all entries in 'PotentialRedundancies' need to be checked
IDsToCheck <- PotentialRedundancies %>% pull(AuxID)
# Data frame that holds pairs of IDs of redundant and respective reference entries
RedundancyPairs <- NULL
# Vector that holds the persisting (so non-redundant) entry IDs throughout function
FinalPersistentIDs <- NULL
while (length(IDsToCheck) > 0)
{
# Subsetting of entries to be investigated in current loop instance
CurrentEntries <- PotentialRedundancies %>%
filter(AuxID %in% IDsToCheck) %>%
mutate(CountRelevantNAs = rowSums(is.na(across(all_of(EssentialFeatures))))) %>%
group_by(across(all_of(DiscriminatoryFeatures))) %>%
arrange(CountRelevantNAs, .by_group = TRUE) %>%      # Put entry with least missing values on first position ('head')
mutate(AuxReferenceID = AuxID[row_number() == 1])
# Pull out and temporarily save IDs of all current 'reference entries' which are the ones that have the least missing values
CurrentReferenceIDs <- CurrentEntries %>%
#--- <Still grouped> ---
slice_head() %>%
ungroup() %>%
pull(AuxID)
# Obtain IDs (based on introduced 'AuxID') of persisting table entries
# Using combination of fill() and distinct() has the effect that all entries that have less or equal informational value compared to 'reference entry' are considered redundant and therefore removed by 'distinct' command
CurrentPersistentIDs <- CurrentEntries %>%
#--- <Still grouped> ---
fill(all_of(EssentialFeatures), .direction = "down") %>%
distinct(across(all_of(EssentialFeatures)), .keep_all = TRUE) %>%
ungroup() %>%
pull(AuxID)
# Obtain pairs of removed AuxIDs and respective AuxReferenceIDs
CurrentRemovedIDs <- CurrentEntries %>%
ungroup() %>%
filter(!(AuxID %in% CurrentPersistentIDs)) %>%
select(AuxID, AuxReferenceID)
# New vector of IDs to be checked
IDsToCheck <- CurrentPersistentIDs %>% base::setdiff(CurrentReferenceIDs)
# Update 'RedundancyPairs'
RedundancyPairs <- rbind(RedundancyPairs, CurrentRemovedIDs)
# Update 'FinalPersistentIDs'
FinalPersistentIDs <- c(FinalPersistentIDs, CurrentReferenceIDs)
}
View(RedundancyPairs)
# Lookup table for AuxIDs and corresponding table-specific IDs (needed only for redundancy pairs)
AuxIDLookup <- Table %>%
select(AuxID, all_of(PrimaryKeyFeature)) %>%
rename(c(ReferenceID = PrimaryKeyFeature))
# Modify 'RedundancyPairs' before linking it with 'Table'
RedundancyPairs <- RedundancyPairs %>%
mutate(IsRedundant = TRUE) %>%      # This will mark all entries in 'Table' that are considered redundant
select(AuxID, IsRedundant, AuxReferenceID)
View(RedundancyPairs)
# Mark redundant entries in original table preserving info about their referenced entries
Table <- Table %>%
left_join(RedundancyPairs, by = join_by(AuxID)) %>%      # This adds column 'AuxReferenceID' to Table, containing AuxIDs of referenced entries for redundant entries
mutate(IsRedundant = coalesce(IsRedundant, FALSE)) %>%      # Replaces all missing values in 'IsRedundant' with 'FALSE'
left_join(AuxIDLookup, by = join_by(AuxReferenceID == AuxID)) %>%      # Turn AuxIDs into original primary keys using previously created 'AuxIDLookup'
arrange(AuxID) %>%       # Reestablish original table order
select(-AuxID,
-AuxReferenceID)      # Auxiliary IDs not needed anymore
# Optionally remove redundant entries from original table. Also remove informative columns about redundancy.
if (RemoveRedundantEntries == TRUE)
{
Table <- Table %>%
filter(!(IsRedundant == TRUE)) %>%
select(-IsRedundant,
-ReferenceID)
}
devtools::load_all(".")
# Find and remove redundant entries in other tables (except 'Patient')
DataSet <- DataSet %>%
imap(function(Table, tablename)
{
if (nrow(Table) > 0 & !(tablename %in% c("Patient", "Diagnosis")))
{
try(ProgressBar$tick())
# For all tables that use 'DiagnosisID', make sure the previously removed DiagnosisIDs are replaced by respective reference DiagnosisIDs...
if (all(c("PatientID", "DiagnosisID") %in% names(Table)))
{
Table <- Table %>%
left_join(Aux_RedundanciesIDMapping, by = join_by(PatientID,
DiagnosisID)) %>%
mutate(DiagnosisID = ifelse(!is.na(ReferenceID),
ReferenceID,
DiagnosisID)) %>%
select(-ReferenceID)
}
# ... then proceed with secondary redundancy removal
Table <- Table %>%
FindRedundantEntries(PrimaryKeyFeature = Meta_Features %>%
filter(TableName_Curated == tablename, IsPrimaryKey = TRUE) %>%
pull(FeatureName_Curated),
DiscriminatoryFeatures = Meta_Features %>%
filter(TableName_Curated == tablename, IsDiscriminatory == TRUE) %>%
pull(FeatureName_Curated),
EssentialFeatures = Meta_Features %>%
filter(TableName_Curated == tablename, IsEssential == TRUE) %>%
pull(FeatureName_Curated),
RemoveRedundantEntries = TRUE)
} else { return(Table) }
})
rlang::last_trace()
View(DataSet$BioSampling)
