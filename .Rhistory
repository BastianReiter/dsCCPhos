IneligibleStrings <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
distinct(Modification) %>%
pull(Modification)
# Auxiliary function to get best fuzzy string match in 'EligibleStringsOriginal' for a particular string
GetBestMatch <- function(String,
EligibleStringsOriginal,
EligibleStringsModification,
Method)
{
# Return NA if String is NA
if (is.na(String)) { return(NA) }
# Compute string distances from current string to all valid strings
Distances <- stringdist(a = String,
b = EligibleStringsMod,
method = Method)
# The current string's lowest distance to any of the valid strings
lowestdistance <- min(Distances)
# Identify the valid string with smallest distance to current string
bestmatch <- EligibleStringsMod[which.min(Distances)]
# Depending on the used method 'lowestdistance' can either already be a number between 0 (no distance) and 1 (maximal distance) or it needs to be normalized accordingly to make the 'Tolerance' argument meaningful
lowestdistance.norm <- lowestdistance      # Methods 'jaccard', 'jw', 'cosine', 'soundex' return distance measures between 0 and 1
if (Method %in% c("osa", "lv", "dl"))      # Length-based edit distances
{
lowestdistance.norm <- lowestdistance / max(nchar(String), nchar(bestmatch))
}
if (Method %in% c("lcs", "qgram"))
{
lowestdistance.norm <- lowestdistance / (nchar(String) + nchar(bestmatch))
}
# Method 'hamming' returns Inf for two strings with different numbers of characters and is therefore not supported (because we can not find a maximum that would allow normalization)
# Get the original value of best match (before valid strings were modified)
bestmatch.original <- EligibleStringsOriginal[which(EligibleStringsMod == bestmatch)]
# If the normalized distance is lower or equal than the 'Tolerance' value, the best match is returned, otherwise return NA
if (lowestdistance.norm <= Tolerance) { return(bestmatch.original) }
else { return(NA) }
}
# Initialize vector for resulting best matches
BestMatches <- NULL
# Auxiliary function to get best fuzzy string match in 'EligibleStringsOriginal' for a particular string
GetBestMatch <- function(String,
EligibleStringsOriginal,
EligibleStringsModification,
Method)
{
# Return NA if String is NA
if (is.na(String)) { return(NA) }
# Compute string distances from current string to all valid strings
Distances <- stringdist(a = String,
b = EligibleStringsModification,
method = Method)
# The current string's lowest distance to any of the valid strings
lowestdistance <- min(Distances)
# Identify the valid string with smallest distance to current string
bestmatch <- EligibleStringsModification[which.min(Distances)]
# Depending on the used method 'lowestdistance' can either already be a number between 0 (no distance) and 1 (maximal distance) or it needs to be normalized accordingly to make the 'Tolerance' argument meaningful
lowestdistance.norm <- lowestdistance      # Methods 'jaccard', 'jw', 'cosine', 'soundex' return distance measures between 0 and 1
if (Method %in% c("osa", "lv", "dl"))      # Length-based edit distances
{
lowestdistance.norm <- lowestdistance / max(nchar(String), nchar(bestmatch))
}
if (Method %in% c("lcs", "qgram"))
{
lowestdistance.norm <- lowestdistance / (nchar(String) + nchar(bestmatch))
}
# Method 'hamming' returns Inf for two strings with different numbers of characters and is therefore not supported (because we can not find a maximum that would allow normalization)
# Get the original value of best match (before valid strings were modified)
bestmatch.original <- EligibleStringsOriginal[which(EligibleStringsModification == bestmatch)]
# If the normalized distance is lower or equal than the 'Tolerance' value, the best match is returned, otherwise return NA
if (lowestdistance.norm <= Tolerance) { return(bestmatch.original) }
else { return(NA) }
}
# Initialize vector for resulting best matches
BestMatches <- NULL
# Suitable methods implemented in 'stringdist::stringdist()'
Methods <- c("osa", "lv", "dl", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex")
# Apply all methods and return results as well as method-specific performance (validity grade)
MethodApplication <- list()
FoundPerfectValidityGrade <- FALSE
i <- 1
while (FoundPerfectValidityGrade == FALSE & i <= length(Methods))
{
CurrentMethod <- Methods[i]
# Get best matches for every element in 'IneligibleStrings' with the current method
BestMatches <- sapply(IneligibleStrings,
GetBestMatch,
EligibleStringsOriginal = EligibleStringsTracker$Original,
EligibleStringsModification = EligibleStringsTracker$Modification,
Method = CurrentMethod)
# Posterior validity grade: To measure method performance calculate proportion of valid elements in 'BestMatches' after matching
ValidityGrade <- sum(BestMatches %in% EligibleStringsOriginal, na.rm = TRUE) / length(BestMatches)
MethodApplication[[CurrentMethod]] <- list(BestMatches = BestMatches,
ValidityGrade = ValidityGrade)
# If a method results in a perfect validity grade (so all elements in 'IneligibleStrings' can be matched with one in 'EligibleStringsOriginal'), the while-loop is stopped to save computational cost
if (ValidityGrade == 1) { FoundPerfectValidityGrade <- TRUE }
i <- i + 1
}
# Transpose list to ease further processing
MethodApplication <- MethodApplication %>% list_transpose()
MethodApplication$ValidityGrade
# Determine best method based on highest posterior validity grade
BestMethod <- Methods[which.max(MethodApplication$ValidityGrade)]
# Get best matches of best method
BestMatches <- MethodApplication$BestMatches[[BestMethod]]
BestMatches
VectorTrackerW <- VectorTracker %>%
mutate(Match = BestMatches[Modification])
View(VectorTrackerW)
?setNames
setNames("ABC", "g")
setNames("ABC", "123")
setNames("ABC", "12/&%$(Â§h")
setNames("ABC", "12/&%$|//\\6h")
# use_r("CompileTransFeatureRules")
# use_r("CompileTransformativeAssignments")
# use_r("CountDeviations")
# use_r("CreateEventFeatures")
# use_r("DataListToDataModel")
# use_r("DataModelToCSV")
# use_r("DataModelToDB")
# use_r("FinalizeDataTransformation")
# use_r("FindRedundantEntries")
# use_r("FormatData")
use_r("GetBestMatch")
devtools::load_all(".")
?map_vec
# Get best matches for every element in 'IneligibleStrings' with the method given in 'PreferredMethod' and return them
BestMatches <- IneligibleStrings %>%
map_vec(function(string) dsCCPhos::GetBestStringMatch(String = string,
EligibleStrings = EligibleStringsTracker$Modification,
Method = PreferredMethod,
Tolerance = Tolerance))
BestMatches
# Get best matches for every element in 'IneligibleStrings' with the method given in 'PreferredMethod' and return them
BestMatches <- IneligibleStrings %>%
map_vec(function(string) dsCCPhos::GetBestStringMatch(String = string,
EligibleStrings = EligibleStringsTracker$Modification,
Method = PreferredMethod,
Tolerance = Tolerance)) %>%
setNames(IneligibleStrings)
BestMatches
# Get best matches for every element in 'IneligibleStrings' with the method given in 'PreferredMethod' and return them
BestMatches <- IneligibleStrings %>%
map_vec(\(string) dsCCPhos::GetBestStringMatch(String = string,
EligibleStrings = EligibleStringsTracker$Modification,
Method = PreferredMethod,
Tolerance = Tolerance)) %>%
setNames(IneligibleStrings)
BestMatches
Vector <- DataSet$Staging$UICCStage
EligibleStrings <- EligibleValueSets$UICCStage
PreferredMethod <- "jw"
FindBestMethod <- TRUE
Tolerance <- 0.5
Preprocessing.FlattenCase <- TRUE
Preprocessing.RemoveAllWhiteSpace <- FALSE
Preprocessing.SquishWhiteSpace <- TRUE
# 'Vector' and 'EligibleStrings' should be of type character already, explicitly convert here to make sure
Vector <- as.character(Vector)
EligibleStrings <- as.character(EligibleStrings)
# Initialize 'VectorTracker' to track processing and matching and to preserve original input vector
VectorTracker <- tibble(ID = 1:length(Vector),
Vector = Vector,
NeedsMatching = !is.na(Vector) & !(Vector %in% EligibleStrings),
Modification = Vector)
# Initialize 'EligibleStringsTracker' to track processing of 'EligibleStrings' (they may be modified to facilitate matching)
EligibleStringsTracker <- tibble(Original = EligibleStrings,
Modification = EligibleStrings)
# For every preprocessing step elements in both 'Vector' AND 'EligibleStrings' are being modified to enhance chance for matching
if (Preprocessing.FlattenCase == TRUE)
{
VectorTracker <- VectorTracker %>% mutate(Modification = tolower(Modification))
EligibleStringsTracker <- EligibleStringsTracker %>% mutate(Modification = tolower(Modification))
}
if (Preprocessing.RemoveAllWhiteSpace == TRUE)
{
VectorTracker <- VectorTracker %>% mutate(Modification = str_replace_all(Modification, " ", ""))      # Remove ALL white space
EligibleStringsTracker <- EligibleStringsTracker %>% mutate(Modification = str_replace_all(Modification, " ", ""))
}
if (Preprocessing.SquishWhiteSpace == TRUE)
{
VectorTracker <- VectorTracker %>% mutate(Modification = str_squish(Modification))      # 'str_squish' removes all leading and trailing white space and reduces all internal white space to a single one
EligibleStringsTracker <- EligibleStringsTracker %>% mutate(Modification = str_squish(Modification))
}
# Filter out non-NA ineligible strings (ie strings that need matching)
IneligibleStrings <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
distinct(Modification) %>%
pull(Modification)
# Initialize vector for resulting best matches
BestMatches <- NULL
# If option 'FindBestMethod' is set to TRUE, try out available methods and choose the one with the highest posterior validity grade
if (FindBestMethod == TRUE)
{
# Suitable methods implemented in 'stringdist::stringdist()'
Methods <- c("osa", "lv", "dl", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex")
# Apply all methods and return results as well as method-specific performance (validity grade)
MethodApplication <- list()
FoundPerfectValidityGrade <- FALSE
i <- 1
while (FoundPerfectValidityGrade == FALSE & i <= length(Methods))
{
CurrentMethod <- Methods[i]
# Get best matches for every element in 'IneligibleStrings' with the current method
BestMatches <- IneligibleStrings %>%
map_vec(\(string) dsCCPhos::GetBestStringMatch(String = string,
EligibleStrings = EligibleStringsTracker$Modification,
Method = CurrentMethod,
Tolerance = Tolerance)) %>%
setNames(IneligibleStrings)
# Posterior validity grade: To measure method performance calculate proportion of valid elements in 'BestMatches' after matching
ValidityGrade <- sum(BestMatches %in% EligibleStringsTracker$Modification, na.rm = TRUE) / length(BestMatches)
MethodApplication[[CurrentMethod]] <- list(BestMatches = BestMatches,
ValidityGrade = ValidityGrade)
# If a method results in a perfect validity grade (so all elements in 'IneligibleStrings' can be matched with one in 'EligibleStringsOriginal'), the while-loop is stopped to save computational cost
if (ValidityGrade == 1) { FoundPerfectValidityGrade <- TRUE }
i <- i + 1
}
# Transpose list to ease further processing
MethodApplication <- MethodApplication %>% list_transpose()
# Determine best method based on highest posterior validity grade
BestMethod <- Methods[which.max(MethodApplication$ValidityGrade)]
# Get best matches of best method
BestMatches <- MethodApplication$BestMatches[[BestMethod]]
} else {
# Get best matches for every element in 'IneligibleStrings' with the method given in 'PreferredMethod'
BestMatches <- IneligibleStrings %>%
map_vec(\(string) dsCCPhos::GetBestStringMatch(String = string,
EligibleStrings = EligibleStringsTracker$Modification,
Method = PreferredMethod,
Tolerance = Tolerance)) %>%
setNames(IneligibleStrings)
}
VectorTrackerW <- VectorTracker %>%
mutate(Match = BestMatches[Modification])
View(VectorTrackerW)
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
mutate(Match = BestMatches[Modification])
BestMatches
BestMatchesW <- EligibleStringsTracker$Original[EligibleStringsTracker$Modification]
BestMatchesW
?join_by
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
mutate(ModificationMatch = BestMatches[Modification]) %>%
left_join(EligibleStringsTracker, by = join_by(ModificationMatch == Modification))
View(VectorTrackerW)
?rename
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
mutate(ModificationMatch = BestMatches[Modification]) %>%
left_join(EligibleStringsTracker, by = join_by(ModificationMatch == Modification)) %>%
rename(Match = "Original")
?is_na
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
mutate(ModificationMatch = BestMatches[Modification]) %>%
left_join(EligibleStringsTracker, by = join_by(ModificationMatch == Modification)) %>%
rename(Match = "Original") %>%
mutate(Output = case_when(!is.na(Match) ~ Match,
.default = Vector))
View(VectorTrackerW)
VectorTrackerW <- VectorTracker %>%
split(.$NeedsMatching)
VectorTrackerW$`FALSE`
?split
VectorTracker.Matches <- VectorTracker %>%
filter(NeedsMatching == TRUE) %>%
mutate(ModificationMatch = BestMatches[Modification]) %>%
left_join(EligibleStringsTracker, by = join_by(ModificationMatch == Modification)) %>%
rename(Match = "Original") %>%
mutate(Output = case_when(!is.na(Match) ~ Match,
.default = Vector))
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == FALSE) %>%
left_join(VectorTracker.Matches, by = join_by(ID))
View(VectorTrackerW)
View(VectorTracker)
VectorTrackerW <- VectorTracker %>%
left_join(VectorTracker.Matches, by = join_by(ID))
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == FALSE) %>%
mutate(Output = Vector) %>%
bind_rows(VectorTracker.Matches)
VectorTrackerW <- VectorTracker %>%
filter(NeedsMatching == FALSE) %>%
mutate(Output = Vector) %>%
bind_rows(VectorTracker.Matches) %>%
arrange(ID)
?arrange
VectorTracker <- VectorTracker %>%
filter(NeedsMatching == FALSE) %>%
mutate(Output = Vector) %>%
bind_rows(VectorTracker.Matches) %>%
arrange(ID)
devtools::load_all(".")
require(stringdist)
stringdist("ABC", c("hkshdk", "jshfasfkv"))
stringdist("ABC", c("hkshdk", "jshfasfkv"), method = NULL)
stringdist("ABC", c("hkshdk", "jshfasfkv"), weight = NULL)
stringdist("ABC", c("hkshdk", "jshfasfkv"), weight = c(1,1,NA,1))
stringdist("ABC", c("hkshdk", "jshfasfkv"), weight = c(1,1,NULL,1))
String <- "ABC"
EligibleStrings <- c("Akdjhnk", "akjdha")
Method <- "jw"
StringdistArguments <- NULL
# Compile arguments for stringdist()
Arguments <- c(list(a = String,
b = EligibleStrings,
method = Method),
StringdistArguments)
Arguments
# Compute string distances from current string to all valid strings
Distances <- do.call(stringdist, Arguments)
Distances
stringdist("ABC", c("hkshdk", "jshfasfkv"), weight = c(1,1,1))
stringdist("ABC", c("hkshdk", "jshfasfkv"), weight = c(1,1,1,1))
test < c(1,2,NA,4)
test <- c(1,2,NA,4)
?any
is.na(test)
any(is.na(test))
?stringdist
devtools::load_all(".")
devtools::load_all(".")
rm(list=ls())
library(dsCCPhos)
library(dplyr)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
#OldTestData <- readRDS(file = "./Development/Data/TestData/OldTestData/CCPTestData.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Rename tables of RawDataSet (the names are also changed when tables are being loaded into R server sessions)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vc_Lookup <- paste0("RDS_", dsCCPhos::Meta_Tables$TableName_Curated)
names(vc_Lookup) <- dsCCPhos::Meta_Tables$TableName_Raw
names(RawDataSet) <- sapply(names(RawDataSet),
function(TableName) { vc_Lookup[TableName] })
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
Settings.S = list(DataHarmonization = list(Run = TRUE,
Profile = "Default"),
FeatureObligations = list(Profile = "Default"),
FeatureTracking = list(Profile = "Default"),
TableCleaning = list(Run = TRUE)))
rlang::last_trace()
?Negate
Test <- list(a = "bsfj", b = "kfhk", c = NA, d = "kjk")
is.na(Test)
Test <- list(a = "bsfj", b = "kfhk", c = NA, d = c(1,5,6,7))
is.na(Test)
devtools::load_all(".")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
Settings.S = list(DataHarmonization = list(Run = TRUE,
Profile = "Default"),
FeatureObligations = list(Profile = "Default"),
FeatureTracking = list(Profile = "Default"),
TableCleaning = list(Run = TRUE)))
rlang::last_trace()
devtools::load_all(".")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
Settings.S = list(DataHarmonization = list(Run = TRUE,
Profile = "Default"),
FeatureObligations = list(Profile = "Default"),
FeatureTracking = list(Profile = "Default"),
TableCleaning = list(Run = TRUE)))
devtools::load_all(".")
devtools::load_all(".")
library(devtools)
# use_r("CleanTable")
# use_r("CompileClassificationCall")
# use_r("CompileDictionaries")
# use_r("CompileTransFeatureRules")
# use_r("CompileTransformativeAssignments")
# use_r("CountDeviations")
# use_r("CreateEventFeatures")
# use_r("DataListToDataModel")
# use_r("DataModelToCSV")
# use_r("DataModelToDB")
use_r("FilterTable")
devtools::load_all(".")
devtools::load_all(".")
?Reduce
devtools::load_all(".")
rm(list=ls())
library(dsCCPhos)
library(dplyr)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
#OldTestData <- readRDS(file = "./Development/Data/TestData/OldTestData/CCPTestData.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Rename tables of RawDataSet (the names are also changed when tables are being loaded into R server sessions)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vc_Lookup <- paste0("RDS_", dsCCPhos::Meta_Tables$TableName_Curated)
names(vc_Lookup) <- dsCCPhos::Meta_Tables$TableName_Raw
names(RawDataSet) <- sapply(names(RawDataSet),
function(TableName) { vc_Lookup[TableName] })
RDSTableCheck <- CheckDataSetDS(DataSetName.S = "RawDataSet",
AssumeCCPDataSet.S = TRUE)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
Settings.S = list(DataHarmonization = list(Run = TRUE,
Profile = "Default"),
FeatureObligations = list(Profile = "Default"),
FeatureTracking = list(Profile = "Default"),
TableCleaning = list(Run = TRUE)))
CuratedDataSet <- CurationOutput$CuratedDataSet
CDSTableCheck <- CheckDataSetDS(DataSetName.S = "CuratedDataSet",
AssumeCCPDataSet.S = TRUE)
AugmentationOutput <- dsCCPhos::AugmentDataDS(CuratedDataSetName.S = "CuratedDataSet")
ADS <- AugmentationOutput$AugmentedDataSet
ADSTableCheck <- CheckDataSetDS(DataSetName.S = "ADS")
ADS_Patient <- ADS$Patient
ADS_Diagnosis <- ADS$Diagnosis
View(ADS_Diagnosis)
View(ADS$Events)
View(ADS$Therapy)
View(Meta_FeatureObligations)
library(dsCCPhos)
library(dplyr)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
#OldTestData <- readRDS(file = "./Development/Data/TestData/OldTestData/CCPTestData.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Rename tables of RawDataSet (the names are also changed when tables are being loaded into R server sessions)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vc_Lookup <- paste0("RDS_", dsCCPhos::Meta_Tables$TableName_Curated)
names(vc_Lookup) <- dsCCPhos::Meta_Tables$TableName_Raw
names(RawDataSet) <- sapply(names(RawDataSet),
function(TableName) { vc_Lookup[TableName] })
RDSTableCheck <- CheckDataSetDS(DataSetName.S = "RawDataSet",
AssumeCCPDataSet.S = TRUE)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
Settings.S = list(DataHarmonization = list(Run = TRUE,
Profile = "Default"),
FeatureObligations = list(Profile = "Default"),
FeatureTracking = list(Profile = "Default"),
TableCleaning = list(Run = TRUE)))
CuratedDataSet <- CurationOutput$CuratedDataSet
CDS <- CuratedDataSet
CDS$Diagnosis
# --- For Testing Purposes ---
TableName.S <- "CDS$Diagnosis"
FilterExpression <- "
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Table <- eval(parse(text = TableName.S), envir = parent.frame())
if (JoinType.S %in% c("left_join", "right_join", "full_join", "inner_join"))
Table <- eval(parse(text = TableName.S), envir = parent.frame())
View(Table)
FilterExpression <- "LocalizationSide == Bilateral"
Output <- eval(parse(text = paste0("dplyr::filter(Table, ", FilterExpression, ")")))
FilterExpression <- "LocalizationSide == 'Bilateral'"
Output <- eval(parse(text = paste0("dplyr::filter(Table, ", FilterExpression, ")")))
View(Output)
devtools::load_all(".")
FilterExpression <- "str_starts(ICD10Code, 'C34')"
Table <- eval(parse(text = TableName.S), envir = parent.frame())
Output <- eval(parse(text = paste0("dplyr::filter(Table, ", FilterExpression, ")")))
View(Output)
devtools::load_all(".")
RawDataSet <- DrawSampleDS(RawDataSetName.S = "RawDataSet",
SampleSize.S = "1000")
View(CDS$Patient)
# --- For Testing Purposes ---
TableName.S <- "CDS$Patient"
FilterExpression.S <- "LastVitalStatus == 'Alive'"
GroupBy.S <- "Gender"
devtools::load_all(".")
# --- For Testing Purposes ---
TableName.S <- "CDS$Patient"
FilterExpression.S <- "LastVitalStatus == 'Alive'"
GroupBy.S <- "Gender"
Table <- eval(parse(text = TableName.S), envir = parent.frame())
if (!is.null(GroupBy.S))
{
Table <- eval(parse(text = paste0("dplyr::group_by(Table, ", GroupBy, ")")))
}
Table <- eval(parse(text = TableName.S), envir = parent.frame())
if (!is.null(GroupBy.S))
{
Table <- eval(parse(text = paste0("dplyr::group_by(Table, ", GroupBy.S, ")")))
}
Table <- eval(parse(text = paste0("dplyr::filter(Table, ", FilterExpression.S, ")")))
Table <- eval(parse(text = "dplyr::ungroup(Table)"))
if (nrow(Table) < 5) { stop("Disclosure Warning: The resulting data.frame has less rows than allowed.")}
View(Table)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
