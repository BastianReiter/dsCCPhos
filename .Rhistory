TransformativeExpressions = TransformativeExpressions,
TransformativeExpressions.Profile = Settings$DataHarmonization$TransformativeExpressions.Profile,
Dictionary = Dictionary,
Dictionary.Profile = Settings$DataHarmonization$Dictionary.Profile,
FuzzyStringMatching = FuzzyStringMatching,
FuzzyStringMatching.Profile = Settings$DataHarmonization$FuzzyStringMatching.Profile)
}
return(Table)
})
#-------------------------------------------------------------------------------
ProgressBar <- progress_bar$new(format = "Harmonizing data... [:bar] :percent in :elapsed  :spin",
total = length(DataSet), clear = FALSE, width = 100)
DataSetW <- DataSet %>%
imap(function(Table, tablename)
{
try(ProgressBar$tick())
Table <- Table %>% mutate(TrackID = row_number())      # Enables tracking of transformation (see above)
if (Settings$DataHarmonization$Run == TRUE)      # The check is placed here and not before the mapping function so that the 'TrackID' is appended regardless (see above)
{
# Get a list of vectors containing the eligible values of corresponding features
EligibleValueSets <- dsCCPhos::Meta_Values %>%
filter(Table == tablename) %>%
select(Feature, Value_Raw) %>%
split(.$Feature) %>%      # 'split' is a base function and needs '.$' to address 'Feature'
map(\(Set) Set$Value_Raw)
# Filter meta data with current table name
Methods <- Settings$DataHarmonization$Methods %>% filter(Table == tablename)
TransformativeExpressions = Settings$DataHarmonization$TransformativeExpressions %>% filter(Table == tablename)
Dictionary <- Settings$DataHarmonization$Dictionary %>% filter(Table == tablename)
FuzzyStringMatching <- Settings$DataHarmonization$FuzzyStringMatching %>% filter(Table == tablename)
# Perform Data Harmonization with table-specific settings
Table <- Table %>%
HarmonizeData(EligibleValueSets = EligibleValueSets,
Methods = Methods,
TransformativeExpressions = TransformativeExpressions,
TransformativeExpressions.Profile = Settings$DataHarmonization$TransformativeExpressions.Profile,
Dictionary = Dictionary,
Dictionary.Profile = Settings$DataHarmonization$Dictionary.Profile,
FuzzyStringMatching = FuzzyStringMatching,
FuzzyStringMatching.Profile = Settings$DataHarmonization$FuzzyStringMatching.Profile)
}
return(Table)
})
try(ProgressBar$terminate())
View(DataSetW$SystemicTherapy)
DataFrame <- DataSet$SystemicTherapy
tablename <- "SystemicTherapy"
EligibleValueSets <- dsCCPhos::Meta_Values %>%
filter(Table == tablename) %>%
select(Feature, Value_Raw) %>%
split(.$Feature) %>%      # 'split' is a base function and needs '.$' to address 'Feature'
map(\(Set) Set$Value_Raw)
Methods <- Settings$DataHarmonization$Methods %>% filter(Table == tablename)
TransformativeExpressions = Settings$DataHarmonization$TransformativeExpressions %>% filter(Table == tablename)
Dictionary <- Settings$DataHarmonization$Dictionary %>% filter(Table == tablename)
FuzzyStringMatching <- Settings$DataHarmonization$FuzzyStringMatching %>% filter(Table == tablename)
TransformativeExpressions.Profile <- "Default"
Dictionary.Profile <- "Default"
FuzzyStringMatching.Profile <- "Default"
Dictionary
# Get names of features where different harmonization methods are supposed to be performed
Features.TransformativeExpressions <- Methods %>% filter(TransformativeExpressions == TRUE) %>% pull(Feature)
Features.Dictionary <- Methods %>% filter(Dictionary == TRUE) %>% pull(Feature)
Features.FuzzyStringMatching <- Methods %>% filter(FuzzyStringMatching == TRUE) %>% pull(Feature)
Features.FuzzyStringMatching
Meta_DataHarmonizationMethods <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "DataHarmonizationMethods",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_DataHarmonizationMethods, overwrite = TRUE)
devtools::load_all(".")
library(dsCCPhos)
library(dplyr)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
#OldTestData <- readRDS(file = "./Development/Data/TestData/OldTestData/CCPTestData.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Rename tables of RawDataSet (the names are also changed when tables are being loaded into R server sessions)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vc_Lookup <- paste0("RDS_", dsCCPhos::Meta_Tables$TableName_Curated)
names(vc_Lookup) <- dsCCPhos::Meta_Tables$TableName_Raw
names(RawDataSet) <- sapply(names(RawDataSet),
function(TableName) { vc_Lookup[TableName] })
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
Settings.S = list(DataHarmonization = list(Run = TRUE,
Profile = "Default"),
FeatureObligations = list(Profile = "Default"),
FeatureTracking = list(Profile = "Default"),
TableCleaning = list(Run = TRUE)))
CuratedDataSet <- CurationOutput$CuratedDataSet
View(CuratedDataSet$SystemicTherapy)
Meta_TableNormalization <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "TableNormalization",
skip = 1)
library(readxl)
library(usethis)
Meta_TableNormalization <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "TableNormalization",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_TableNormalization, overwrite = TRUE)
Meta_FuzzyStringMatching <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "FuzzyStringMatching",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_FuzzyStringMatching, overwrite = TRUE)
devtools::load_all(".")
library(readxl)
library(usethis)
Meta_CancerGrouping <- TinkerLab::CancerGrouping
# Save data in .rda-file and make it part of package
use_data(Meta_CancerGrouping, overwrite = TRUE)
Meta_DataHarmonizationMethods <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "DataHarmonizationMethods",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_DataHarmonizationMethods, overwrite = TRUE)
Meta_DiagnosisAssociation <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "DiagnosisAssociation")
# Save data in .rda-file and make it part of package
use_data(Meta_DiagnosisAssociation, overwrite = TRUE)
Meta_DiagnosisRedundancy <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "DiagnosisRedundancy")
# Save data in .rda-file and make it part of package
use_data(Meta_DiagnosisRedundancy, overwrite = TRUE)
Meta_Dictionary <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "Dictionary",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_Dictionary, overwrite = TRUE)
Meta_EventFeatures <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "EventFeatures")
# Save data in .rda-file and make it part of package
use_data(Meta_EventFeatures, overwrite = TRUE)
Meta_FeatureObligations <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "FeatureObligations",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_FeatureObligations, overwrite = TRUE)
Meta_Features <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "Features")
# Save data in .rda-file and make it part of package
use_data(Meta_Features, overwrite = TRUE)
Meta_FeatureTracking <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "FeatureTracking",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_FeatureTracking, overwrite = TRUE)
Meta_FuzzyStringMatching <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "FuzzyStringMatching",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_FuzzyStringMatching, overwrite = TRUE)
Meta_TableNormalization <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "TableNormalization",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_TableNormalization, overwrite = TRUE)
Meta_Tables <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "Tables")
# Save data in .rda-file and make it part of package
use_data(Meta_Tables, overwrite = TRUE)
Meta_TransformativeExpressions <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "TransformativeExpressions",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_TransformativeExpressions, overwrite = TRUE)
Meta_Values <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "Values",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_Values, overwrite = TRUE)
length(NULL)
devtools::load_all(".")
library(dsCCPhos)
library(dplyr)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
#OldTestData <- readRDS(file = "./Development/Data/TestData/OldTestData/CCPTestData.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Rename tables of RawDataSet (the names are also changed when tables are being loaded into R server sessions)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vc_Lookup <- paste0("RDS_", dsCCPhos::Meta_Tables$TableName_Curated)
names(vc_Lookup) <- dsCCPhos::Meta_Tables$TableName_Raw
names(RawDataSet) <- sapply(names(RawDataSet),
function(TableName) { vc_Lookup[TableName] })
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
Settings.S = list(DataHarmonization = list(Run = TRUE,
Profile = "Default"),
FeatureObligations = list(Profile = "Default"),
FeatureTracking = list(Profile = "Default"),
TableCleaning = list(Run = TRUE)))
CuratedDataSet <- CurationOutput$CuratedDataSet
# --- For Testing Purposes ---
ObjectName.S <- "CuratedDataSet$Staging"
# Initiate output list
MetaData <- list()
Object <- get(ObjectName.S, envir = parent.frame())
Object <- eval(parse(text = ObjectName.S), envir = parent.frame())
View(Object)
Object <- eval(parse(text = "ABC"), envir = parent.frame())
MetaData$ObjectExists <- TRUE
MetaData$Class <- class(Object)[1]      # Some objects return more than one string as class info (e.g. ResourceClient objects). Take only first string for these cases.
MetaData$Length <- length(Object)
MetaData$RowCount <- nrow(Object)
MetaData$Names <- names(Object)
DataTypesList <- lapply(Object, class)      # Get class/type of every element in 'Object'. This call returns a list...
MetaData$DataTypes <- sapply(DataTypesList, paste, collapse = "/")      # ... and in case the 'class' of an element of 'Object' returns more than one string, these are concatenated to get one string per element, thus obtaining a character vector for MetaData$DataTypes
MetaData$DataTypes
MetaData$Structure <- data.frame(Element = MetaData$Names,
Type = MetaData$DataTypes,
row.names = NULL)
Test <- GetTableCheckDS(TableName.S = ObjectName.S)
devtools::load_all(".")
Test <- GetTableCheckDS(TableName.S = ObjectName.S)
devtools::load_all(".")
CDS_BioSampling <- CuratedDataSet$BioSampling
# --- For Testing Purposes ---
ObjectName.S <- "CDS_BioSampling"
# Initiate output list
MetaData <- list()
Object <- get(ObjectName.S, envir = parent.frame())
MetaData$ObjectExists <- TRUE
MetaData$Class <- class(Object)[1]      # Some objects return more than one string as class info (e.g. ResourceClient objects). Take only first string for these cases.
MetaData$Length <- length(Object)
MetaData$RowCount <- nrow(Object)
MetaData$Names <- names(Object)
?exists
get("ABC", envir = parent.frame())
CDS_BioSampling <- NULL
Object <- get(ObjectName.S, envir = parent.frame())
MetaData$ObjectExists <- TRUE
MetaData$Class <- class(Object)[1]      # Some objects return more than one string as class info (e.g. ResourceClient objects). Take only first string for these cases.
MetaData$Length <- length(Object)
MetaData$RowCount <- nrow(Object)
MetaData$Names <- names(Object)
# If 'Object' is a list or a data.frame, get 1) data types of contained elements and 2) structural overview
if (MetaData$Class %in% c("list", "data.frame"))
{
DataTypesList <- lapply(Object, class)      # Get class/type of every element in 'Object'. This call returns a list...
MetaData$DataTypes <- sapply(DataTypesList, paste, collapse = "/")      # ... and in case the 'class' of an element of 'Object' returns more than one string, these are concatenated to get one string per element, thus obtaining a character vector for MetaData$DataTypes
MetaData$Structure <- data.frame(Element = MetaData$Names,
Type = MetaData$DataTypes,
row.names = NULL)
if (MetaData$Class == "data.frame")
{
MetaData$Structure <- GetTableCheckDS(TableName.S = ObjectName.S)$FeatureCheck %>%
select(Feature,
Type,
NonMissingValueRate)
}
}
MetaData
?get
library(dsCCPhos)
library(dplyr)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
#OldTestData <- readRDS(file = "./Development/Data/TestData/OldTestData/CCPTestData.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Rename tables of RawDataSet (the names are also changed when tables are being loaded into R server sessions)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vc_Lookup <- paste0("RDS_", dsCCPhos::Meta_Tables$TableName_Curated)
names(vc_Lookup) <- dsCCPhos::Meta_Tables$TableName_Raw
names(RawDataSet) <- sapply(names(RawDataSet),
function(TableName) { vc_Lookup[TableName] })
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
Settings.S = list(DataHarmonization = list(Run = TRUE,
Profile = "Default"),
FeatureObligations = list(Profile = "Default"),
FeatureTracking = list(Profile = "Default"),
TableCleaning = list(Run = TRUE)))
# --- For Testing Purposes ---
ObjectName.S <- "CDS_Diagnosis"
# Initiate output list
MetaData <- list()
Object <- get(ObjectName.S, envir = parent.frame())
# --- For Testing Purposes ---
ObjectName.S <- "RDS_Diagnosis"
Object <- get(ObjectName.S, envir = parent.frame())
CDS_Diagnosis <- CurationOutput$CuratedDataSet$Diagnosis
# --- For Testing Purposes ---
ObjectName.S <- "CDS_Diagnosis"
# Initiate output list
MetaData <- list()
Object <- get(ObjectName.S, envir = parent.frame())
MetaData$ObjectExists <- TRUE
MetaData$Class <- class(Object)[1]      # Some objects return more than one string as class info (e.g. ResourceClient objects). Take only first string for these cases.
MetaData$Length <- length(Object)
MetaData$RowCount <- nrow(Object)
MetaData$Names <- names(Object)
DataTypesList <- lapply(Object, class)      # Get class/type of every element in 'Object'. This call returns a list...
MetaData$DataTypes <- sapply(DataTypesList, paste, collapse = "/")      # ... and in case the 'class' of an element of 'Object' returns more than one string, these are concatenated to get one string per element, thus obtaining a character vector for MetaData$DataTypes
MetaData$Structure <- data.frame(Element = MetaData$Names,
Type = MetaData$DataTypes,
row.names = NULL)
MetaData$Structure <- GetTableCheckDS(TableName.S = ObjectName.S)$FeatureCheck %>%
select(Feature,
Type,
NonMissingValueRate)
MetaData$Structure
MetaData$Structure <- CheckTable(Table = Object)
MetaData$Structure
Object <- get(ObjectName.S, envir = parent.frame())
MetaData$ObjectExists <- TRUE
MetaData$Class <- class(Object)[1]      # Some objects return more than one string as class info (e.g. ResourceClient objects). Take only first string for these cases.
MetaData$Length <- length(Object)
MetaData$RowCount <- nrow(Object)
MetaData$Names <- names(Object)
# If 'Object' is a list or a data.frame, get 1) data types of contained elements and 2) structural overview
if (MetaData$Class %in% c("list", "data.frame"))
{
DataTypesList <- lapply(Object, class)      # Get class/type of every element in 'Object'. This call returns a list...
MetaData$DataTypes <- sapply(DataTypesList, paste, collapse = "/")      # ... and in case the 'class' of an element of 'Object' returns more than one string, these are concatenated to get one string per element, thus obtaining a character vector for MetaData$DataTypes
MetaData$Structure <- data.frame(Element = MetaData$Names,
Type = MetaData$DataTypes,
NonMissingValueRate = NULL,
row.names = NULL)
if (MetaData$Class == "data.frame")
{
MetaData$Structure <- CheckTable(Table = Object)$FeatureCheck %>%
select(Feature,
Type,
NonMissingValueRate) %>%
rename(Element = "Feature") %>%
as.data.frame()
}
}
MetaData$Structure <- data.frame(Element = MetaData$Names,
Type = MetaData$DataTypes,
NonMissingValueRate = NA,
row.names = NULL)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
library(dsCCPhos)
library(dplyr)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
#OldTestData <- readRDS(file = "./Development/Data/TestData/OldTestData/CCPTestData.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Rename tables of RawDataSet (the names are also changed when tables are being loaded into R server sessions)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vc_Lookup <- paste0("RDS_", dsCCPhos::Meta_Tables$TableName_Curated)
names(vc_Lookup) <- dsCCPhos::Meta_Tables$TableName_Raw
names(RawDataSet) <- sapply(names(RawDataSet),
function(TableName) { vc_Lookup[TableName] })
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
Settings.S = list(DataHarmonization = list(Run = TRUE,
Profile = "Default"),
FeatureObligations = list(Profile = "Default"),
FeatureTracking = list(Profile = "Default"),
TableCleaning = list(Run = TRUE)))
CuratedDataSet <- CurationOutput$CuratedDataSet
AugmentationOutput <- dsCCPhos::AugmentDataDS(CuratedDataSetName.S = "CuratedDataSet")
ADS <- AugmentationOutput$AugmentedDataSet
View(ADS$DiseaseCourse)
Table <- CDS_Diagnosis
require(dplyr)
require(tidyr)
# Initiate output object
TableCheck <- NULL
# Identify missing features
PresentFeatureNames <- names(Table)
MissingFeatures <- RequiredFeatureNames[!(RequiredFeatureNames %in% PresentFeatureNames)]
# --- For Testing Purposes ---
Table <- CDS_Diagnosis
RequiredFeatureNames <- NULL
# Identify missing features
PresentFeatureNames <- names(Table)
MissingFeatures <- RequiredFeatureNames[!(RequiredFeatureNames %in% PresentFeatureNames)]
# If no 'RequiredFeatureNames' are passed, assign feature names of Table per default
if (is.null(RequiredFeatureNames)) { RequiredFeatureNames <- names(Table) }
# Initiate output object
TableCheck <- NULL
# Identify missing features
PresentFeatureNames <- names(Table)
MissingFeatures <- RequiredFeatureNames[!(RequiredFeatureNames %in% PresentFeatureNames)]
TableComplete <- (length(MissingFeatures) == 0)
# Get table row count
RowCount <- nrow(Table)
# Get summarizing data.frame that contains info about existence of table features
FeatureExistence <- tibble(Feature = RequiredFeatureNames) %>%
mutate(Exists = case_when(Feature %in% PresentFeatureNames ~ TRUE,
.default = FALSE))
# Get types/classes of table features
FeatureTypes <- Table %>%
summarize(across(everything(), ~ typeof(.x))) %>%
pivot_longer(cols = everything(),
names_to = "Feature",
values_to = "Type")
# Get absolute count of non-missing values per table feature
NonMissingValueCounts <- Table %>%
summarize(across(everything(), ~ sum(!(is.na(.x) | (is.character(.x) & .x == ""))))) %>%
pivot_longer(cols = everything(),
names_to = "Feature",
values_to = "NonMissingValueCount")
# Get rate of non-missing values per table feature
NonMissingValueRates <- Table %>%
summarize(across(everything(), ~ sum(!(is.na(.x) | (is.character(.x) & .x == ""))) / n())) %>%
pivot_longer(cols = everything(),
names_to = "Feature",
values_to = "NonMissingValueRate")
# Consolidate feature meta data in one data.frame
FeatureCheck <- FeatureExistence %>%
left_join(FeatureTypes, by = join_by(Feature)) %>%
left_join(NonMissingValueCounts, by = join_by(Feature)) %>%
left_join(NonMissingValueRates, by = join_by(Feature))
View(FeatureCheck)
devtools::load_all(".")
test <- data.frame()
typeof(test))
typeof(test)
class(test)
typeof(CDS_Diagnosis)
test <- tibble()
test <- tibble::tibble()
class(test)
typeof(test)
"data.frame" %in% class(CDS_Diagnosis)
if ("data.frame" %in% class(test))
"data.frame" %in% class(test)
"data.frame" %in% class(test)
library(readxl)
library(usethis)
Meta_CancerGrouping <- TinkerLab::CancerGrouping
# Save data in .rda-file and make it part of package
use_data(Meta_CancerGrouping, overwrite = TRUE)
Meta_DataHarmonizationMethods <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "DataHarmonizationMethods",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_DataHarmonizationMethods, overwrite = TRUE)
Meta_DiagnosisAssociation <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "DiagnosisAssociation")
# Save data in .rda-file and make it part of package
use_data(Meta_DiagnosisAssociation, overwrite = TRUE)
Meta_DiagnosisRedundancy <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "DiagnosisRedundancy")
# Save data in .rda-file and make it part of package
use_data(Meta_DiagnosisRedundancy, overwrite = TRUE)
Meta_Dictionary <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "Dictionary",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_Dictionary, overwrite = TRUE)
Meta_EventFeatures <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "EventFeatures")
# Save data in .rda-file and make it part of package
use_data(Meta_EventFeatures, overwrite = TRUE)
Meta_FeatureObligations <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "FeatureObligations",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_FeatureObligations, overwrite = TRUE)
Meta_Features <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "Features")
# Save data in .rda-file and make it part of package
use_data(Meta_Features, overwrite = TRUE)
Meta_FeatureTracking <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "FeatureTracking",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_FeatureTracking, overwrite = TRUE)
Meta_FuzzyStringMatching <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "FuzzyStringMatching",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_FuzzyStringMatching, overwrite = TRUE)
Meta_TableNormalization <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "TableNormalization",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_TableNormalization, overwrite = TRUE)
Meta_Tables <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "Tables")
# Save data in .rda-file and make it part of package
use_data(Meta_Tables, overwrite = TRUE)
Meta_TransformativeExpressions <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "TransformativeExpressions",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_TransformativeExpressions, overwrite = TRUE)
Meta_Values <- read_excel(path = "./Development/Data/MetaData/MetaDataCCPhos.xlsx",
sheet = "Values",
skip = 1)
# Save data in .rda-file and make it part of package
use_data(Meta_Values, overwrite = TRUE)
